name: Terraform Action
description: Run terraform

inputs:
  terraform-command:
    required: true
    description: The Terraform command to run
  terraform-use-backend:
    required: false
    description: 'Whether to use a backend configuration for Terraform.'
    default: "true"
  terraform-options:
    required: false
    description: 'The options to use in the Terraform configuration.'
    default: ""
  fail-on-exit-code:
    required: false
    description: 'Whether to fail the action if the Terraform command exits with a non-zero exit code.'
    default: "true"
  always-run-init:
    required: false
    description: 'Whether to always run terraform init.'
    default: "false"
  working-directory:
    description: "Directory containing the project files"
    required: false
    default: ""
  terraform-directory:
    description: "Directory where Terraform environment directories are located"
    required: true
  env-mapping-directory:
    description: "Which environment directory to use"
    required: true
  git-sha:
    required: true
    description: "Git SHA to use for versioning"

outputs:
  exitcode:
    description: 'The exit code of the Terraform command.'
    value: ${{ steps.terraform.outputs.exitcode }}
  stdout:
    description: 'The standard output of the Terraform command.'
    value: ${{ steps.terraform.outputs.stdout }}

runs:
  using: composite
  steps:
    - name: Determine Terraform directory using autodiscovery
      id: tf-dir-autodiscovery
      uses: nsbno/platform-actions/.github/actions/helpers/terraform-directory-autodiscovery@v2
      with:
        working-directory: ${{ inputs.working-directory }}
        terraform-directory: ${{ inputs.terraform-directory }}
        env-mapping-directory: ${{ inputs.env-mapping-directory }}

    - name: Validate Terraform directory exists
      id: tf-dir
      shell: bash
      run: |
        if [ "${{ steps.tf-dir-autodiscovery.outputs.exists }}" != "true" ]; then
          echo "::error::No valid Terraform directory found for environment '${{ inputs.env-mapping-directory }}'"
          exit 1
        fi
        echo "dir=${{ steps.tf-dir-autodiscovery.outputs.directory }}" >> $GITHUB_OUTPUT

    - name: Find Terraform version
      shell: bash
      run: |
        set -e
        dirs=(
          "${{ steps.tf-dir.outputs.dir }}"
          "${{ inputs.working-directory }}/infrastructure"
          "${{ inputs.working-directory }}/terraform/template"
          "${{ inputs.working-directory }}/terraform"
        )
        echo "Searching for Terraform version in directories: ${dirs[*]}"
        for dir in "${dirs[@]}"; do
          echo "Checking directory: $dir"
          if [ -d "$dir" ]; then
            version=$(grep -rEho 'required_version *= *"[^"]+"' "$dir" --include \*.tf | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)
            if [ -n "$version" ]; then
              echo "Found Terraform version: $version"
              echo "TERRAFORM_VERSION=$version" >> $GITHUB_ENV
              exit 0
            fi
          fi
        done
        echo "::error title=Terraform version not found::Could not determine required Terraform version."
        exit 1

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Cache Terraform
      id: terraform-cache
      uses: actions/cache@v4
      with:
        path: ${{ github.workspace }}/${{ steps.tf-dir.outputs.dir }}/.terraform
        key: ${{runner.os}}-${{ steps.tf-dir.outputs.dir }}-terraform-${{ inputs.git-sha }}
        restore-keys: |
          ${{runner.os}}-${{ steps.tf-dir.outputs.dir }}-terraform-${{ inputs.git-sha }}

    # This will register the GitHub repository name and working directory to be used in Terraform version tracking
    - name: Register version to deployment version handler
      uses: nsbno/platform-actions/.github/actions/helpers/register-version@v2
      with:
        working-directory: ${{ inputs.working-directory }}
        git-sha-to-register: ${{ inputs.git-sha }}

    - name: Terraform Init
      if: steps.restore-terraform.outputs.cache-hit == 'false' || inputs.always-run-init == 'true'
      shell: bash
      working-directory: ${{ steps.tf-dir.outputs.dir }}
      run: |
        set -e
        terraform init --backend=${{ inputs.terraform-use-backend }}

    - name: Terraform Command
      working-directory: ${{ steps.tf-dir.outputs.dir }}
      id: terraform
      shell: bash
      run: terraform ${{ inputs.terraform-command }} ${{ inputs.terraform-options }}

    # Workaround for releasing lock if cancelling a Terraform job
    # https://github.com/orgs/community/discussions/26311#discussioncomment-11263095
    - name: Release lock if exists
      if: always() && steps.terraform.outcome == 'cancelled'
      working-directory: ${{ steps.tf-dir.outputs.dir }}
      shell: bash
      run: |
        lock_id=$(terraform plan -no-color -refresh=false 2>&1 | grep ' ID: ' | cut -d: -f2 | tr -d ' ' || true)
        if [[ -n "${lock_id}" ]]; then
          terraform force-unlock -force ${lock_id}
        fi

    - name: Terraform Output
      continue-on-error: ${{ inputs.fail-on-exit-code == 'false' }}
      shell: bash
      run: |
        if [ "${{ steps.terraform.outputs.exitcode }}" = "1" ]; then
          echo "Terraform failed with an error."
        elif [ "${{ steps.terraform.outputs.exitcode }}" = "2" ]; then
          echo "Terraform succeeded with changes present."
        else
          echo "Terraform exited with an unexpected code: ${{ steps.terraform.outputs.exitcode }}"
        fi
